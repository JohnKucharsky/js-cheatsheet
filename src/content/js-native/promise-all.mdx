
## Promise.all

The Promise.all() static method takes an iterable of promises as
input and returns a single Promise. This returned promise fulfills
when all the input's promises fulfill (including when an empty
iterable is passed), with an array of the fulfillment values. It
rejects when any of the input's promises rejects, with this first
rejection reason.

```js
function myPromiseAll(promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError("Argument must be an array"));
    }

    let results = [];
    let completedPromises = 0;

    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then((value) => {
          results[index] = value;
          console.log(value);
          completedPromises += 1;
          if (completedPromises === promises.length) {
            resolve(results);
          }
        })
        .catch(reject);
    });

    if (promises.length === 0) {
      resolve([]);
    }
  });
}

const promise1 = new Promise((resolve, reject) => {
  setTimeout(resolve, 3000, "first");
});
const promise2 = new Promise((resolve, reject) => {
  setTimeout(resolve, 1000, "second");
});
const promise3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 5000, "third");
});

myPromiseAll([promise1, promise2, promise3]).then((values) => {
  console.log(values);
});

// second
// first
// third
// [ 'first', 'second', 'third' ]
```

### First Approach:

- Promises can run concurrently, potentially resulting in faster total
execution time when multiple promises can resolve in parallel.
- The outer promise resolves as soon as all inner promises have settled.

### Second Approach:

- Promises are awaited sequentially, which can be less efficient as it waits
for each promise to resolve before starting the next one.
- This can lead to longer execution times, especially if promises have
varying completion times.

```js
async function myPromiseAll(promises) {
  if (!Array.isArray(promises)) {
    throw new TypeError("Argument must be an array");
  }

  const results = [];

  // If the array is empty, return an empty array immediately
  if (promises.length === 0) {
    return results;
  }

  for (let index = 0; index < promises.length; index++) {
    try {
      // Promise.resolve to ensure that function can handle
      // non-promise values
      const value = await Promise.resolve(promises[index]);
      results[index] = value;
      console.log(value);
    } catch (error) {
      throw error;
    }
  }

  return results;
}

const promise1 = new Promise((resolve) => {
  setTimeout(resolve, 3000, "first");
});
const promise2 = new Promise((resolve) => {
  setTimeout(resolve, 1000, "second");
});
const promise3 = new Promise((resolve) => {
  setTimeout(resolve, 5000, "third");
});

myPromiseAll([promise1, promise2, promise3])
  .then((values) => {
    console.log(values);
  })
  .catch((error) => {
    console.error(error);
  });

// first
// second
// third
// [ 'first', 'second', 'third' ]
```
