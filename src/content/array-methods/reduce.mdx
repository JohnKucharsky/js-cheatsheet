
## reduce

Executes a user-supplied "reducer" callback function on each element
of the array, in order, passing in the return value from the calculation
on the preceding element. The final result of running the reducer across
all elements of the array is a single value.

The first time that the callback is run there is no "return value of the
previous calculation". If supplied, an initial value may be used in its
place. Otherwise, the array element at index 0 is used as the initial value
and iteration starts from the next element (index 1 instead of index 0).

```js
Array.prototype.customReduce = function (callback, initialValue) {
  let accumulator = initialValue !== undefined ? initialValue : this[0];

  for (let i = initialValue !== undefined ? 0 : 1; i < this.length; i++) {
    accumulator = callback(accumulator, this[i], i, this);
  }

  return accumulator;
};

const array1 = [15, 16, 17, 18, 19];

// 15 + 16 + 17 + 18 + 19
const initialValue = 0;
const sumWithInitial = array1.customReduce(
  (accumulator, currentValue) => accumulator + currentValue,
  initialValue,
);
console.log(sumWithInitial); // 85

// no initial value, first element is array[0]
// 15 + 16 + 17 + 18 + 19
const sumWithoutInitial = array1.customReduce(
  (accumulator, currentValue) => accumulator + currentValue,
);
console.log(sumWithoutInitial); // 85

const pipe =
  (...functions) =>
  (initialValue) =>
    functions.customReduce((acc, fn) => fn(acc), initialValue);

// Building blocks to use for composition
const double = (x) => 2 * x;
const triple = (x) => 3 * x;

// Composed functions for multiplication of specific values
const multiply6 = pipe(double, triple);
const multiply9 = pipe(triple, triple);

// Usage
console.log(multiply6(6)); // 36
console.log(multiply9(9)); // 81

// Compare this with pipe: fn(acc) is changed to acc.then(fn),
// and initialValue is ensured to be a promise
const asyncPipe =
  (...functions) =>
  (initialValue) =>
    functions.customReduce(
      (acc, fn) => acc.then(fn),
      Promise.resolve(initialValue),
    );

// Building blocks to use for composition
const p1 = async (a) => a * 5;
const p2 = async (a) => a * 2;
// The composed functions can also return non-promises, because the values are
// all eventually wrapped in promises
const f3 = (a) => a * 3;
const p4 = async (a) => a * 4;

asyncPipe(p1, p2, f3, p4)(10).then(console.log); // 1200

// same with async/await
const asyncPipeAsync =
  (...functions) =>
  (initialValue) =>
    functions.customReduce(async (acc, fn) => fn(await acc), initialValue);
```
