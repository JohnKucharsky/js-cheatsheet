## Learn JS tasks

### fibonacci

The sequence of [Fibonacci numbers](https://en.wikipedia.org/wiki/Fibonacci_number) has
the formula <code>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub></code>. In other words,
the next number is a sum of the two preceding ones.
First two numbers are `1`, then `2(1+1)`, then `3(1+2)`, `5(2+3)` and so on: `1, 1, 2, 3, 5, 8, 13, 21...`

```js title="fibonacci loop"
function fib(n) {
  let a = 1;
  let b = 1;
  for (let i = 3; i <= n; i++) {
    let c = a + b;
    a = b;
    b = c;
  }
  return b;
}

console.log(fib(3)); // 2
console.log(fib(7)); // 13
console.log(fib(77)); // 5527939700884757
```

```js title="fibonacci recursion"
function fib(n) {
  return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}

console.log(fib(3)); // 2
console.log(fib(7)); // 13
console.log(fib(77)); // -
```

### shooters

Every function is meant to output its number.

```js title="shooters"
function makeArmy() {
  let shooters = [];

  let i = 0;
  while (i < 10) {
    let j = i; // save local variable
    let shooter = function () {
      // create a shooter function,
      return j; // that should show its number
    };
    shooters.push(shooter); // and add it to the array
    i++;
  }

  // ...and return the array of shooters
  return shooters;
}

let army = makeArmy();

console.log(army[0]()); // 0
console.log(army[1]()); // 1
console.log(army[5]()); // 5
```

### currying

Sum with an arbitrary amount of brackets.

```js title="currying"
function sum(a) {
  let currentSum = a;

  function f(b) {
    currentSum += b;
     return f;
  }

  f.toString = function () {
    return currentSum;
  };

  return f;
}

console.log(sum(1)(2)); // 3
console.log(sum(5)(-1)(2)); // 6
console.log(sum(6)(-1)(-2)(-3)); // 0
console.log(sum(0)(1)(2)(3)(4)(5)); // 15
```

### timout vs interval

Sum with an arbitrary amount of brackets.

```js title="timout vs interval"
function printNumbersInterval(from, to) {
  let current = from;

  let timerId = setInterval(function () {
    console.log(`interval-${current}`);
    if (current === to) {
      clearInterval(timerId);
    }
    current++;
  }, 1000);
}

printNumbersInterval(2, 4);

function printNumbersTimout(from, to) {
  let current = from;

  setTimeout(function go() {
    console.log(`timout-${current}`);
    if (current < to) {
      setTimeout(go, 1000);
    }
    current++;
  }, 1000);
}

printNumbersTimout(5, 7);

function printNumbersFromFirstSecond(from, to) {
  let current = from;

  function go() {
    console.log(current);
    if (current === to) {
      clearInterval(timerId);
    }
    current++;
  }

  go();
  let timerId = setInterval(go, 1000);
}

printNumbersFromFirstSecond(9, 11);

// 9
// interval-2
// timout-5
// 10
// interval-3
// timout-6
// 11
// interval-4
// timout-7
```

### spy decorator

Decorator spy(func) return a wrapper that saves all calls to function in
its "calls" property. Every call is saved as an array of arguments.

```js title="spy decorator"
function spy(func) {
  function wrapper(...args) {
    // using ...args instead of arguments to store "real" array in wrapper.calls
    wrapper.calls.push(args);
    return func.apply(this, args);
  }

  wrapper.calls = [];

  return wrapper;
}

function work(a, b) {
  return `${a + b} ${this.value}`; // work is an arbitrary function or method
}

const spyObj = {
  value: "this value",
  work: spy(work),
};

console.log(spyObj.work(1, 2)); // 3 this value
console.log(spyObj.work.calls); // [ [ 1, 2 ] ]

work = spy(work);
console.log(work(1, 2)); // 3 undefined
console.log(work(4, 5)); // 9 undefined
console.log(work.calls); // [ [ 1, 2 ], [ 4, 5 ] ]
```

### delay decorator

Decorator delay(f, ms) delays each call of f by ms milliseconds.

```js title="delay decorator"
function delay(f, ms) {
  return function () {
    setTimeout(() => f.apply(this, arguments), ms);
  };
}

function f(x) {
  console.log(this.value, x);
}

// create wrappers
const f1000 = {
  value: "this value",
  funcCall: delay(f, 1000),
};

let f1500 = delay(f, 1500);

f1000.funcCall("test1000"); // this value test1000 after 1000ms
f1500("test1500"); // undefined test1500 1500ms
```

### debounce decorator

Decorator is a wrapper that suspends calls to f until there’s ms
milliseconds of inactivity (no calls, “cooldown period”), then invokes
f once with the latest arguments.

```js title="debounce decorator"
function debounce(func, ms) {
  let timeout;
  return function () {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, arguments), ms);
  };
}

// runs only the last one
const f = debounce(console.log, 1000);
f("a"); // skip
setTimeout(() => f("b"), 200); // skip
setTimeout(() => f("c"), 500); // run after 1000ms

const f2 = debounce(console.log, 100);
f2("a"); // runs after 100
setTimeout(() => f2("b"), 200); // runs after 200
setTimeout(() => f2("c"), 500); // run after 500ms

// if called together
// a
// b
// c
// c
```

### throttling decorator

When it's called multiple times, it passes the call to `f` at maximum once
per `ms` milliseconds.
Compared to the debounce decorator, the behavior is completely different:
- `debounce` runs the function once after the "cooldown" period. Good for
processing the final result.
- `throttle` runs it not more often than given `ms` time. Good for regular
updates that shouldn't be very often.

In other words, `throttle` is like a secretary that accepts phone calls, but
bothers the boss (calls the actual `f`) not more often than once per `ms` milliseconds.


```js title="throttling decorator"
function throttle(func, ms) {
  let isThrottled = false,
    savedArgs,
    savedThis;

  function wrapper() {
    if (isThrottled) {
      // In this state all calls are memorized in savedArgs/savedThis.
      // Please note that both the context and the arguments are
      // equally important and should be memorized. We need them
      // simultaneously to reproduce the call.
      savedArgs = arguments;
      savedThis = this;
      return;
    }
    isThrottled = true;
    // first call runs func and sets
    // is Throttled to true
    func.apply(this, arguments);

    setTimeout(function () {
      isThrottled = false;
      // After ms milliseconds pass, setTimeout triggers. The cooldown
      // state is removed (isThrottled = false) and, if we had ignored calls,
      // wrapper is executed with the last memorized arguments and context.
      if (savedArgs) {
        // call wrapper to repeat all again
        wrapper.apply(savedThis, savedArgs);
        savedArgs = savedThis = null;
      }
    }, ms);
  }

  return wrapper;
}

function f(a) {
  console.log(a);
}

// f1000 passes calls to f at maximum once per 1000 ms
let f1000 = throttle(f, 1000);

f1000(1); // shows 1
f1000(2); // (throttling, 1000ms not out yet)
f1000(3); // (throttling, 1000ms not out yet)

// when 1000 ms time out...
// ...outputs 3, intermediate value 2 was ignored
```

