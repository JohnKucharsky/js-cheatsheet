### concat

Merge two or more arrays. This method does not change the
existing arrays, but instead returns a new array.

```js title="Array.prototype.concat()"
Array.prototype.myConcat = function (...arrays) {
  const result = [];
  for (let i = 0; i < this.length; i++) {
    result[result.length] = this[i];
  }
  for (const array of arrays) {
    if (Array.isArray(array)) {
      for (let i = 0; i < array.length; i++) {
        result[result.length] = array[i];
      }
    } else {
      result[result.length] = array;
    }
  }
  return result;
};

const arr = [1, 2, 3];
const arr2 = [4, 5, 6, [1]];
const arr3 = [7, 8, 9];
const concat = arr.myConcat(arr2, arr3, 10);
console.log(concat);
// Output: [1, 2, 3, 4, 5, 6, [1], 7, 8, 9, 10]
```

### copyWithin

Shallow copies part of this array to another location in the same array
and returns this array without modifying its length.

```js title="Array.prototype.copyWithin()"
Array.prototype.myCopyWithin = function (
  target = 0,
  start = 0,
  end = this.length,
) {
  if (this === null || this === undefined) {
    throw new TypeError("this is null or undefined");
  }

  let object = Object(this);
  let length = parseInt(object.length, 10);

  if (start === undefined) {
    throw new TypeError("start is undefined");
  }

  if (end === null || end === undefined) {
    end = length;
  }

  let to = target < 0 ? Math.max(length + target, 0) : Math.min(target, length);
  let from = start < 0 ? Math.max(length + start, 0) : Math.min(start, length);
  let last = end < 0 ? Math.max(length + end, 0) : Math.min(end, length);
  let count = Math.min(last - from, length - to);
  let direction = 1;

  if (from < to && to < from + count) {
    direction = -1;
    from += count - 1;
    to += count - 1;
  }

  while (count > 0) {
    if (from in object) {
      object[to] = object[from];
    } else {
      delete object[to];
    }

    from += direction;
    to += direction;
    count--;
  }

  return object;
};

const arr = ['a', 'b', 'c', 'd', 'e'];

// Copy to index 0 the element at index 3
console.log(arr.copyWithin(0, 3, 4));
// Expected output: Array ["d", "b", "c", "d", "e"]

// Copy to index 1 all elements from index 3 to the end
console.log(arr.copyWithin(1, 3));
// Expected output: Array ["d", "d", "e", "d", "e"]

console.log([1, 2, 3, 4, 5].myCopyWithin(0, 3));
// [4, 5, 3, 4, 5]
console.log([1, 2, 3, 4, 5].myCopyWithin(0, 3, 4));
// [4, 2, 3, 4, 5]
console.log([1, 2, 3, 4, 5].myCopyWithin(-2, -3, -1));
// [1, 2, 3, 3, 4]
```

### entries

Returns a new array iterator object that contains the key/value pairs
for each index in the array.

```js title="Array.prototype.entries()"
Array.prototype.customEntries = function () {
  const entries = [];
  for (let i = 0; i < this.length; i++) {
    entries.push([i, this[i]]);
  }

  function* iterator() {
    yield* entries;
  }

  return iterator();
};

const array1 = ['a', 'b', 'c', 'd', 'e'];

// Copy to index 0 the element at index 3
console.log(array1.copyWithin(0, 3, 4));
// Expected output: Array ["d", "b", "c", "d", "e"]

// Copy to index 1 all elements from index 3 to the end
console.log(array1.copyWithin(1, 3));
// Expected output: Array ["d", "d", "e", "d", "e"]

const arr = ["a", "b", "c"];
const iterator = arr.customEntries();

console.log(iterator.next());
// { value: [ 0, 'a' ], done: false }
console.log(iterator.next());
// { value: [ 1, 'b' ], done: false }
console.log(iterator.next());
// { value: [ 2, 'c' ], done: false }
console.log(iterator.next());
// { value: undefined, done: true }

for (const [index, element] of arr.customEntries()) {
  console.log(index, element);
}
// 0 a
// 1 b
// 2 c
```

### every

Tests whether all elements in the array pass the test implemented by the provided function.
It returns a Boolean value.

```js title="Array.prototype.every()"
Array.prototype.customEvery = function (callback) {
  if (!callback) {
    throw new TypeError("callback must be a function");
  }

  for (let i = 0; i < this.length; i++) {
    if (!callback.call(this, this[i])) {
      return false;
    }
  }

  return true;
};

const arr = [1, 30, 39, 29, 10, 13];

console.log(arr.customEvery((currentValue) => currentValue > 40));
// false
console.log(arr.customEvery((currentValue) => currentValue < 40));
// true

const isSubset = (array1, array2) =>
  array2.customEvery((element) => array1.includes(element));

console.log(isSubset([1, 2, 3, 4, 5, 6, 7], [5, 7, 6]));
// true
console.log(isSubset([1, 2, 3, 4, 5, 6, 7], [5, 8, 7]));
// false
```

### fill

Changes all elements within a range of indices in an array to a static value.
It returns the modified array.

```js title="Array.prototype.fill()"
Array.prototype.customFill = function (value, start = 0, end = this.length) {
  if (start < 0) {
    start = this.length + start;
  }

  if (end < 0) {
    end = this.length + end;
  }

  for (let i = start; i < end; i++) {
    this[i] = value;
  }

  return this;
};

const array1 = [1, 2, 3, 4];

// Fill with 0 from position 2 until position 4
console.log(array1.customFill(0, 2, 4));
// Expected output: Array [1, 2, 0, 0]

// Fill with 5 from position 1
console.log(array1.customFill(5, 1));
// Expected output: Array [1, 5, 5, 5]

console.log(array1.customFill(6));
// Expected output: Array [6, 6, 6, 6]

console.log([1, 2, 3].customFill(4)); // [4, 4, 4]
console.log([1, 2, 3].customFill(4, 1)); // [1, 4, 4]
console.log([1, 2, 3].customFill(4, 1, 2)); // [1, 4, 3]
console.log([1, 2, 3].customFill(4, 1, 1)); // [1, 2, 3]
console.log([1, 2, 3].customFill(4, 3, 3)); // [1, 2, 3]
```

### filter

Creates a shallow copy of a portion of a given array, filtered down to just the elements
from the given array that pass the test implemented by the provided function.

```js title="Array.prototype.filter()"
Array.prototype.myFilter = function (callback) {
  const result = [];

  for (let i = 0; i < this.length; i++) {
    if (callback(this[i], i, this)) {
      result.push(this[i]);
    }
  }

  return result;
};

const words = ["spray", "elite", "exuberant", "destruction", "present"];

const result = words.myFilter((word) => word.length > 6);

console.log(result);
// Array ["exuberant", "destruction", "present"]

const array = [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];

function isPrime(num) {
  for (let i = 2; num > i; i++) {
    if (num % i === 0) {
      return false;
    }
  }
  return num > 1;
}

console.log(array.myFilter(isPrime)); // [2, 3, 5, 7, 11, 13]
```

### find

Returns the first element in the provided array that satisfies the
provided testing function. If no values satisfy the testing function,
undefined is returned.

```js title="Array.prototype.find()"
Array.prototype.customFind = function (callback) {
  if (!callback) {
    throw new TypeError("callback must be a function");
  }

  for (let i = 0; i < this.length; i++) {
    if (callback.call(this, this[i])) {
      return this[i];
    }
  }

  return undefined;
};

const array1 = [5, 12, 8, 130, 44];
const found = array1.customFind((element) => element > 10);
console.log(found);
// Expected output: 12

const inventory = [
  { name: "apples", quantity: 2 },
  { name: "bananas", quantity: 0 },
  { name: "cherries", quantity: 5 },
];

const result = inventory.customFind(({ name }) => name === "cherries");
console.log(result); // { name: 'cherries', quantity: 5 }

const result1 = inventory.customFind(({ name }) => name === "nothing");
console.log(result1); // undefined
```

### findIndex

Returns the index of the first element in an array that satisfies
the provided testing function. If no elements satisfy the testing function,
-1 is returned.

```js title="Array.prototype.findIndex()"
Array.prototype.customFindIndex = function (callback) {
  if (!callback) {
    throw new TypeError("callback must be a function");
  }

  for (let i = 0; i < this.length; i++) {
    if (callback.call(this, this[i])) {
      return i;
    }
  }

  return -1;
};

const array1 = [5, 12, 8, 130, 44];
const found = array1.customFindIndex((element) => element > 10);
console.log(found); // 1

const inventory = [
  { name: "apples", quantity: 2 },
  { name: "bananas", quantity: 0 },
  { name: "cherries", quantity: 5 },
];

const result = inventory.customFindIndex(({ name }) => name === "cherries");
console.log(result); // 2

const result1 = inventory.customFindIndex(({ name }) => name === "nothing");
console.log(result1); // -1
```

### findLast

Iterates the array in reverse order and returns the value of the first element that
satisfies the provided testing function. If no elements satisfy the testing function,
undefined is returned.

```js title="Array.prototype.findLast()"
Array.prototype.customFindLast = function (callback) {
  if (!callback) {
    throw new TypeError("callback must be a function");
  }

  for (let i = this.length; i >= 0; i--) {
    if (callback.call(this, this[i])) {
      return this[i];
    }
  }

  return undefined;
};

const array1 = [5, 12, 8, 130, 44];
const found = array1.customFindLast((element) => element > 10);
console.log(found);
// Expected output: 44
```

### flat

Creates a new array with all sub-array elements concatenated
into it recursively up to the specified depth.

```js title="Array.prototype.flat()"
Array.prototype.customFlat = function (d = 1) {
  function flat(depth) {
    if (depth) {
      return Array.prototype.reduce.call(
        this,
        function (acc, cur) {
          if (Array.isArray(cur)) {
            acc.push.apply(acc, flat.call(cur, depth - 1));
          } else {
            acc.push(cur);
          }

          return acc;
        },
        [],
      );
    }
    return Array.prototype.slice.call(this);
  }

  return flat.call(this, d);
};

const arr1 = [0, 1, 2, [3, 4]];

console.log(arr1.customFlat());
// expected output: Array [0, 1, 2, 3, 4]

const arr2 = [0, 1, [2, [3, [4, 5]]]];

console.log(arr2.customFlat());
// expected output: Array [0, 1, 2, Array [3, Array [4, 5]]]

console.log(arr2.customFlat(2));
// expected output: Array [0, 1, 2, 3, Array [4, 5]]

console.log(arr2.customFlat(Infinity));
// expected output: Array [0, 1, 2, 3, 4, 5]
```