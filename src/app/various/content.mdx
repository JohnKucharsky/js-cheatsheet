[back](/)

# Random

## hasAllItems

```js title="hasAllItems"
const hasAllElements = ({ arrayToCheck, baseArray }) => {
  const set = new Set(baseArray);

  for (let i = 0; i < arrayToCheck.length; i++) {
    if (!set.has(arrayToCheck[i])) {
      return false;
    }
  }

  return true;
};

const arr1 = [1, 2, 3];
const arr2 = [3, 5, 4, 2, 7, 0, 1, 10];

console.log(hasAllElements({ arrayToCheck: arr1, baseArray: arr2 })); // true
```

## call stack

```js title="call stack"
function first() {
  second();
  console.log("first");
}
function second() {
  third();
  console.log("second");
}
function third() {
  console.log("third");
}
first();
// third
// second
// first

function first2() {
  console.log("first");
  second2();
}
function second2() {
  console.log("second");
  third2();
}
function third2() {
  console.log("third");
}
first2();
// first
// second
// third

function recursive(n) {
  console.log(n);
  if (n === 0) {
    return n;
  }
  return recursive(n - 1);
}
recursive(2); // 2 1 0
```

## stack palindrome

```js title="palindrome"
function isPalindrome(word) {
  const letters = []; // this is our stack
  let reversedWord = "";

  // put letters of word into stack
  for (let i = 0; i < word.length; i++) {
    letters.push(word[i]);
  }

  // pop off the stack in reverse order
  for (let i = 0; i < word.length; i++) {
    reversedWord += letters.pop();
  }

  return reversedWord === word;
}

console.log(isPalindrome("racecar")); // true
```

## Stack

```js title="Stack"
class Stack {
  constructor() {
    this.count = 0;
    this.storage = {};
  }

  push(value) {
    this.storage[this.count] = value;
    this.count++;
    return this;
  }
  pop() {
    if (this.count === 0) {
      return undefined;
    }

    this.count--;
    delete this.storage[this.count];
    return this;
  }
  size() {
    return this.count;
  }
  peek() {
    return this.storage[this.count - 1];
  }
}

const myStack = new Stack();

myStack.push(1).push(2).push(3);
// [ 1, 2, 3 ]
myStack.peek(); // 3
myStack.pop(); // [ 1, 2 ]
myStack.peek(); // 2
myStack.push("freeCodeCamp");
// [ 1, 2, 'freeCodeCamp' ]
myStack.size(); // 3
myStack.pop(); // [ 1, 2 ]
myStack.peek(); // 2
```

## Set js implementation

JS Set with additional methods

```js title="Set"
class MySet {
  constructor() {
    this.collection = {};
  }

  has(element) {
    return Boolean(this.collection[element]);
  }
  values() {
    return Object.values(this.collection);
  }
  add(element) {
    if (!this.collection[element]) {
      this.collection[element] = element;
      return true;
    }

    return false;
  }
  remove(element) {
    if (this.has(element)) {
      delete this.collection[element];
      return true;
    }

    return false;
  }
  get size() {
    return Object.values(this.collection).length;
  }
  clear() {
    this.collection = {};
    return this;
  }
  union(otherSet) {
    const unionSet = new MySet();
    const firstSet = this.values();
    const secondSet = otherSet.values();

    firstSet.forEach(function (e) {
      unionSet.add(e);
    });
    secondSet.forEach(function (e) {
      unionSet.add(e);
    });

    return unionSet;
  }
  intersection(otherSet) {
    const intersectionSet = new MySet();
    const firstSet = this.values();

    firstSet.forEach(function (e) {
      if (otherSet.has(e)) {
        intersectionSet.add(e);
      }
    });

    return intersectionSet;
  }
  difference(otherSet) {
    const differenceSet = new MySet();
    const firstSet = this.values();

    firstSet.forEach(function (e) {
      if (!otherSet.has(e)) {
        differenceSet.add(e);
      }
    });

    return differenceSet;
  }
  subset(otherSet) {
    const firstSet = this.values();

    return firstSet.every(function (value) {
      return otherSet.has(value);
    });
  }
}

const setA = new MySet();
const setB = new MySet();
setA.add("a");
setB.add("b");
setB.add("c");
setB.add("a");
setB.add("d");
setB.has("b"); // true
setA.subset(setB); // true
setA.intersection(setB).values();
// [ 'a' ]
setB.difference(setA).values();
// [ 'b', 'c', 'd' ]
const unionSet = setB.union(setA);
unionSet.remove("c"); // true
unionSet.size; // 3
unionSet.clear().values(); // []
```

## Queue

```js title="Queue"
class Queue {
  constructor() {
    this.collection = [];
  }

  enqueue(element) {
    this.collection.push(element);
    return this;
  }
  dequeue() {
    this.collection.shift();
    return this;
  }
  front() {
    return this.collection[0];
  }
  get size() {
    return this.collection.length;
  }
  isEmpty() {
    return this.collection.length === 0;
  }
}

const queue = new Queue();
queue.enqueue("one").enqueue("two");
// [ 'one', 'two' ]
queue.dequeue(); // [ 'two' ]
queue.enqueue("three").enqueue("four");
// [ 'two', 'three', 'four' ]
queue.front(); // two
queue.size; // 3
queue.isEmpty(); // false
```

## priority queue

```js title="PriorityQueue"
class PriorityQueue {
  constructor() {
    this.collection = [];
  }

  printCollection() {
    console.log(this.collection);
  }
  enqueue(element) {
    if (this.isEmpty()) {
      this.collection.push(element);
    } else {
      let added = false;
      for (let i = 0; i < this.collection.length; i++) {
        if (element[1] < this.collection[i][1]) {
          //checking priorities
          this.collection.splice(i, 0, element);
          added = true;
          break;
        }
      }
      if (!added) {
        this.collection.push(element);
      }
    }
  }
  dequeue() {
    let value = this.collection.shift();
    return value[0];
  }
  front() {
    return this.collection[0];
  }
  size() {
    return this.collection.length;
  }
  isEmpty() {
    return this.collection.length === 0;
  }
}

const priorityQueue = new PriorityQueue();
priorityQueue.enqueue(["Audi", 2]);
priorityQueue.enqueue(["Subaru", 3]);
priorityQueue.enqueue(["BMW", 1]);
priorityQueue.enqueue(["Mercedes", 2]);
priorityQueue.printCollection();
// [
//   [ 'BMW', 1 ],
//   [ 'Audi', 2 ],
//   [ 'Mercedes', 2 ],
//   [ 'Subaru', 3 ]
// ]
priorityQueue.dequeue();
console.log(priorityQueue.front()); // [ 'Audi', 2 ]
priorityQueue.printCollection();
// [ [ 'Audi', 2 ], [ 'Mercedes', 2 ], [ 'Subaru', 3 ] ]
```

## Map

```js title="Map"
class MyMap {
  constructor() {
    this.collection = {};
    this.count = 0;
  }

  size() {
    return this.count;
  }
  set(key, value) {
    this.collection[key] = value;
    this.count++;
  }
  has(key) {
    return key in this.collection;
  }
  get(key) {
    return key in this.collection ? this.collection[key] : null;
  }
  remove(key) {
    if (key in this.collection) {
      delete this.collection[key];
      this.count--;
    }
  }
  values() {
    const collectionValues = Object.values(this.collection);
    return collectionValues.length > 0 ? collectionValues : null;
  }
  clear() {
    this.collection = {};
    this.count = 0;
  }
}

const map = new MyMap();
map.set("arms", 2);
map.set("fingers", 10);
map.set("eyes", 2);
map.set("belley button", 1);

console.log(map.get("fingers")); // 10
console.log(map.size()); // 4
console.log(map.values());
// [ 2, 10, 2, 1 ]

const map2 = new Map();
const keyObj = {};
const keyFunc = function () {};

map2.set("hello", "string value");
map2.set(keyObj, "obj value");
map2.set(keyFunc, "func value");
map2.set(NaN, "NaN value");

console.log(map2);
// Map(4) {
//   'hello' => 'string value',
//   {} => 'obj value',
//   [Function: keyFunc] => 'func value',
//   NaN => 'NaN value'
// }

console.log(map2.get("hello")); // string value
console.log(map2.get(keyObj)); // obj value
console.log(map2.get(keyFunc)); // func value
console.log(map2.get(NaN)); // NaN value
```