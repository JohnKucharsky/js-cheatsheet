[back](/)

# Leetcode

## length of last word

Given a string s consisting of words and spaces, return the length
of the last word in the string. A word is a maximal substring consisting
of non-space characters only.

**Example 1:**
**Input:** s = "Hello World"
**Output:** 5
**Explanation:** The last word is "World" with length 5.

**Example 2:**
**Input:** s = "   fly me   to   the moon  "
**Output:** 4
**Explanation:** The last word is "moon" with length 4.

```js title="factorial"
function lengthOfLastWord(s) {
  let res = 0;

  for (let i = s.length - 1; i >= 0; i--) {
    if (s[i] !== " ") res++;
    else {
      if (res > 0) return res;
    }
  }

  return res;
}

const str1 = "Hello World";
const str2 = "   fly me   to   the moon  ";
console.log(lengthOfLastWord(str1)); // 5
console.log(lengthOfLastWord(str2)); // 4
```

## best time to buy and sell stock

You are given an array prices where prices[i] is the price of a
given stock on the ith day. You want to maximize your profit by
choosing a single day to buy one stock and choosing a different
day in the future to sell that stock. Return the maximum profit
you can achieve from this transaction. If you cannot achieve any
profit, return 0.

**Example 1:**
**Input:** prices = [7,1,5,3,6,4]
**Output:** 5
**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.

**Example 2:**
**Input:** prices = [7,6,4,3,1]
**Output:** 0
**Explanation:** In this case, no transactions are done and the max profit = 0.

```js title="maxProfit"
function maxProfit(prices) {
  let buyPrice = prices[0];
  let profit = 0;

  for (let i = 1; i < prices.length; i++) {
    if (buyPrice > prices[i]) {
      buyPrice = prices[i];
    }

    profit = Math.max(profit, prices[i] - buyPrice);
  }

  return profit;
}

const arr1 = [7, 1, 5, 3, 6, 4];
const arr2 = [7, 6, 4, 3, 1];

console.log(maxProfit(arr1)); // 5
console.log(maxProfit(arr2)); // 0
```

## prime number

A whole number greater than 1 that cannot be exactly divided by
any whole number other than itself and 1 (e.g. 2, 3, 5, 7, 11).

```js title="isPrime"
function isPrime(n) {
  if (n < 2) {
    return false;
  }

  for (let i = 2; i <= Math.sqrt(n); i++) {
    // if n is divisible by any number then it is not prime
    if (n % i === 0) {
      return false;
    }
  }

  return true;
}

console.log(isPrime(1)); // false
console.log(isPrime(5)); // true
console.log(isPrime(4)); // false
```

## binary search

```js title="binarySearch"
function binarySearch(arr, target) {
  let leftIndex = 0;
  let rightIndex = arr.length - 1;

  while (leftIndex <= rightIndex) {
    const middleIndex = Math.floor((leftIndex + rightIndex) / 2);
    if (target === arr[middleIndex]) {
      return middleIndex;
    }
    if (target < arr[middleIndex]) {
      rightIndex = middleIndex - 1;
    } else {
      leftIndex = middleIndex + 1;
    }
  }

  return -1;
}

console.log(binarySearch([-5, 2, 4, 6, 10], 10)); // 4
console.log(binarySearch([-5, 2, 4, 6, 10], 6)); // 3
console.log(binarySearch([-5, 2, 4, 6, 10], 20)); // -1
```

## bubble sort

Bubble Sort is the simplest sorting algorithm that works by
repeatedly swapping the adjacent elements if they are in the wrong order

```js title="bubbleSort"
function bubbleSort(arr) {
  let swapped;
  do {
    swapped = false;
    for (let i = 0; i < arr.length - 1; i++) {
      if (arr[i] > arr[i + 1]) {
        let temp = arr[i];
        arr[i] = arr[i + 1];
        arr[i + 1] = temp;
        swapped = true;
      }
    }
  } while (swapped);
}

const arr = [8, 20, -2, 4, -6];
bubbleSort(arr);
console.log(arr); // [-6, -2, 4, 8, 20]
```

## insertion sort

Insertion sort is a simple sorting algorithm that works by
iteratively inserting each element of an unsorted list into
its correct position in a sorted portion of the list

```js title="insertionSort"
function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let numberToInsert = arr[i];
    let j = i - 1;
    // Move elements of arr[0..i-1], that are
    // greater than key, to one position ahead
    // of their current position
    while (j >= 0 && arr[j] > numberToInsert) {
      arr[j + 1] = arr[j];
      j = j - 1;
    }
    arr[j + 1] = numberToInsert;
  }
}

const arr = [8, 20, -2, 4, -6];
insertionSort(arr);
console.log(arr); // [-6, -2, 4, 8, 20]
```

## quick sort

QuickSort is a sorting algorithm based on the **Divide and Conquer**
that picks an element as a pivot and partitions the given array around
the picked pivot by placing the pivot in its correct position in the sorted array

```js title="quickSort"
function quickSort(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    const pivot = partition(arr, left, right);
    quickSort(arr, left, pivot - 1);
    quickSort(arr, pivot + 1, right);
  }
  return arr;
}

function partition(arr, left, right) {
  const pivot = arr[right];
  let i = left;
  for (let j = left; j < right; j++) {
    if (arr[j] < pivot) {
      swap(arr, i, j);
      i++;
    }
  }
  swap(arr, i, right);
  return i;
}

function swap(arr, i, j) {
  const temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}

const arr = [8, 20, -2, 4, -6];
quickSort(arr);
console.log(arr); // [-6, -2, 4, 8, 20]
```