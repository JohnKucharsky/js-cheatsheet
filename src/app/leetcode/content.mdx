[back](/)

# Leetcode

## length of the last word

Given a string s consisting of words and spaces, return the length
of the last word in the string. A word is a maximal substring consisting
of non-space characters only.

**Example 1:** \
**Input:** s = "Hello World" \
**Output:** 5 \
**Explanation:** The last word is "World" with length 5.

**Example 2:** \
**Input:** s = "   fly me   to   the moon  " \
**Output:** 4 \
**Explanation:** The last word is "moon" with length 4.

```js title="factorial"
function lengthOfLastWord(s) {
  let res = 0;

  for (let i = s.length - 1; i >= 0; i--) {
    if (s[i] !== " ") res++;
    else {
      if (res > 0) return res;
    }
  }

  return res;
}

const str1 = "Hello World";
const str2 = "   fly me   to   the moon  ";
console.log(lengthOfLastWord(str1)); // 5
console.log(lengthOfLastWord(str2)); // 4
```

## best time to buy and sell stock

You are given an array prices where prices[i] is the price of a
given stock on the ith day. You want to maximize your profit by
choosing a single day to buy one stock and choosing a different
day in the future to sell that stock. Return the maximum profit
you can achieve from this transaction. If you cannot achieve any
profit, return 0.

**Example 1:** \
**Input:** prices = [7,1,5,3,6,4] \
**Output:** 5 \
**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.

**Example 2:** \
**Input:** prices = [7,6,4,3,1] \
**Output:** 0 \
**Explanation:** In this case, no transactions are done and the max profit = 0.

```js title="maxProfit"
function maxProfit(prices) {
  let buyPrice = prices[0];
  let profit = 0;

  for (let i = 1; i < prices.length; i++) {
    if (buyPrice > prices[i]) {
      buyPrice = prices[i];
    }

    profit = Math.max(profit, prices[i] - buyPrice);
  }

  return profit;
}

const arr1 = [7, 1, 5, 3, 6, 4];
const arr2 = [7, 6, 4, 3, 1];

console.log(maxProfit(arr1)); // 5
console.log(maxProfit(arr2)); // 0
```

## summary ranges

Given a sorted unique integer array, we need to find contiguous ranges of numbers
and represent them ina specific format. If a range consists of consecutive numbers,
we represent it as "a->b". If it's a single number, it's represented as just "a"

**Example 1:** \
**Input:** nums = [0,1,2,4,5,7] \
**Output:** ["0->2","4->5","7"] \
**Explanation:** The ranges are: \
[0,2] --> "0->2" \
[4,5] --> "4->5" \
[7,7] --> "7"

**Example 2:** \
**Input:** nums = [0,2,3,4,6,8,9] \
**Output:** ["0","2->4","6","8->9"] \
**Explanation:** The ranges are: \
[0,0] --> "0" \
[2,4] --> "2->4" \
[6,6] --> "6" \
[8,9] --> "8->9"

```typescript title="summaryRanges"
function summaryRanges(nums: number[]) {
  let result = [];
  let start = nums[0];
  for (let i = 1; i <= nums.length; i++) {
    if (nums[i] - nums[i - 1] === 1) continue;
    if (start === nums[i - 1]) {
      result.push(`${start}`);
    } else {
      result.push(`${start}->${nums[i - 1]}`);
    }
    start = nums[i];
  }
  return result;
}

console.log(summaryRanges([1, 2, 2, 3, 1, 4]));
// [ '1->2', '2->3', '1', '4' ]
console.log(summaryRanges([0, 1, 2, 4, 5, 7]));
// [ '0->2', '4->5', '7' ]
console.log(summaryRanges([0, 2, 3, 4, 6, 8, 9]));
// [ '0', '2->4', '6', '8->9' ]
```

## power of two

Check if number is power of 2. `2^30` is the largest power of two within
the range of a 32-bit signed integer

```typescript title="isPowerOfTwo"
function isPowerOfTwo(n: number) {
  for (let i = 0; i < 31; i++) {
    if (Math.pow(2, i) === n) {
      return true;
    }
  }
  return false;
}

console.log(isPowerOfTwo(16)); // true
console.log(isPowerOfTwo(1)); // true
console.log(isPowerOfTwo(3)); // false
```

## find the peaks

You are given a 0-indexed array mountain. Your task is to find all the peaks in the mountain array.
Return an array that consists of indices of peaks in the given array in any order.

Example 1: \
Input: `mountain = [2,4,4]` \
Output: `[]` \
Explanation: `mountain[0]` and `mountain[2]` can not be a peak because they are first and last elements of the array.
`mountain[1]` also can not be a peak because it is not strictly greater than `mountain[2]`.
So the answer is `[]` \

Example 2: \
Input: `mountain = [1,4,3,8,5]` \
Output: [1,3] \
Explanation: `mountain[0]` and `mountain[4]` can not be a peak because they are first and last elements of the array.
`mountain[2]` also can not be a peak because it is not strictly greater than `mountain[3]` and `mountain[1]`.
But `mountain[1]` and `mountain[3]` are strictly greater than their neighboring elements.
So the answer is `[1,3]`

```typescript title="findPeaks"
function findPeaks(mountain: number[]) {
  const peaks = [];
  const n = mountain.length;

  for (let i = 1; i < n - 1; i++) {
    if (
      mountain[i] > mountain[i - 1] &&
      mountain[i] > mountain[i + 1]
    ) {
      peaks.push(i);
    }
  }

  return peaks;
}

console.log(findPeaks([2, 4, 4])); // []
console.log(findPeaks([1, 4, 3, 8, 5])); // [ 1, 3 ]
```

## count the number of incremovable subarrays I

A subarray of nums is called incremovable if nums becomes strictly increasing on
removing the subarray. For example, the subarray `[3, 4]` is an incremovable subarray
of `[5, 3, 4, 6, 7]` because removing this subarray changes the array `[5, 3, 4, 6, 7]`
to `[5, 6, 7]` which is strictly increasing. Return the total number of incremovable
subarrays of nums. Note that an empty array is considered strictly increasing.
A subarray is a contiguous non-empty sequence of elements within an array.

**Example 1:** \
**Input:** nums = [1,2,3,4] \
**Output:** 10 \
**Explanation:** The 10 incremovable subarrays are: `[1]`, `[2]`, `[3]`, `[4]`, `[1,2]`, `[2,3]`,
`[3,4]`, `[1,2,3]`, `[2,3,4]`, and `[1,2,3,4]`, because on removing any one of these subarrays
nums becomes strictly increasing. Note that you cannot select an empty subarray. \

**Example 2:** \
**Input:** nums = `[6,5,7,8]` \
**Output:** 7 \
**Explanation:** The 7 incremovable subarrays are: `[5]`, `[6]`, `[5,7]`, `[6,5]`, `[5,7,8]`, `[6,5,7]` and `[6,5,7,8]`.
It can be shown that there are only 7 incremovable subarrays in nums.


```typescript title="incremovableSubarrayCount"
function incremovableSubarrayCount(nums: number[]) {
  let count = 1;
  let right = 1;
  const n = nums.length;

  while (right < n && nums[right] > nums[right - 1]) {
    right++;
  }

  if (right === n) {
    return (n * (n + 1)) / 2;
  }

  let last = Number.MAX_SAFE_INTEGER;
  count += right;

  for (let i = n - 1; i >= 0; i--) {
    if (nums[i] >= last) {
      break;
    }
    let low = 0,
      high = right - 1;
    let left = -1;

    while (low <= high) {
      let mid = Math.floor((low + high) / 2);
      if (nums[mid] < nums[i]) {
        left = mid;
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }

    count += left + 2;
    last = nums[i];
  }

  return count;
}

console.log(incremovableSubarrayCount([1, 2, 3, 4])); // 10
console.log(incremovableSubarrayCount([6, 5, 7, 8])); // 7
```

## count elements with maximum frequency

Return the total frequencies of elements in nums such that those elements all
have the maximum frequency. The frequency of an element is the number of occurrences
of that element in the array.

**Example 1:**
**Input:** nums = `[1,2,2,3,1,4]`
**Output:** 4
**Explanation:** Elements 1 and 2 have a frequency of 2 which is the maximum frequency in the array.
So the number of elements in the array with maximum frequency is 4

**Example 2:**
**Input:** nums = `[1,2,3,4,5]`
**Output:** 5
**Explanation:** All elements of the array have a frequency of 1 which is the maximum.
So the number of elements in the array with maximum frequency is 5

```typescript title="maxFrequencyElements"
function maxFrequencyElements(nums: number[]) {
  const freqCounter = new Map();

  let maxFrequency = 1;

  // Iterate through the array and update the frequency of each number
  for (const num of nums) {
    freqCounter.set(num, (freqCounter.get(num) || 0) + 1);
    maxFrequency = Math.max(
      maxFrequency,
      freqCounter.get(num),
    );
  }

  let total = 0;

  for (const freq of freqCounter.values()) {
    if (freq === maxFrequency) {
      total = total + freq;
    }
  }

  return total;
}

console.log(maxFrequencyElements([1, 2, 2, 3, 1, 4])); // 4
console.log(maxFrequencyElements([1, 2, 2, 2, 1, 4])); // 3
console.log(maxFrequencyElements([1, 2, 3, 4, 5])); // 5
```