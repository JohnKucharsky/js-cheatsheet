## Leetcode

### prefix sum

```js title="prefix sum"
function prefixSum(arr) {
  let prefix = new Array(arr.length);
  prefix[0] = arr[0];

  for (let i = 1; i < arr.length; i++) {
    prefix[i] = prefix[i - 1] + arr[i];
  }

  return prefix;
}

// Example usage
let arr = [1, 2, 3, 4, 5];
console.log(prefixSum(arr));
// Output: [1, 3, 6, 10, 15]
```

### ranges sum query

`NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1])`\
`numArray.sumRange(0, 2)` // output (-2) + 0 + 3 = 1\
`numArray.sumRange(2, 5)` // output 3 + (-5) + 2 + (-1) = -1\
`numArray.sumRange(0, 5)` // output (-2) + 0 + 3 + (-5) + 2 + (-1) = -3

```js title="ranges sum query"
class NumArray {
  constructor(nums) {
    this.prefixSums = new Array(nums.length + 1).fill(0);
    for (let i = 0; i < nums.length; i++) {
      this.prefixSums[i + 1] = this.prefixSums[i] + nums[i];
    }
    console.log(this.prefixSums);
    // [0, -2, -2, 1, -4, -2, -3];
  }

  sumRange(left, right) {
    return this.prefixSums[right + 1] - this.prefixSums[left];
  }
}

const numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
console.log(numArray.sumRange(0, 2)); // output: 1
console.log(numArray.sumRange(2, 5)); // output: -1
console.log(numArray.sumRange(0, 5)); // output: -3
```

### subarray sum equals k

nums = `[1,1,1]`, k = `2` // output: 2\
nums = `[1,2,3]`, k = `3` // output: 2

```js title="subarray sum equals k"
function subarraySum(nums, k) {
  let sum = 0;
  let count = 0;
  let map = new Map();
  map.set(0, 1);

  for (let i = 0; i < nums.length; i++) {
    sum += nums[i];
    const remainder = sum - k;

    if (map.has(remainder)) {
      count += map.get(remainder);
    }

    const frequency = map.get(sum) || 0;

    map.set(sum, frequency + 1);
  }

  return count;
}

const nums = [1, 1, 1];
const k = 2;
console.log(subarraySum(nums, k)); // output: 2

const nums2 = [1, 4, -1, 5, 2, 3, 0];
const k2 = 3;
console.log(subarraySum(nums2, k2)); // output: 3
```

### palindrome

A palindrome is a word, number, phrase, or other sequence of symbols
that reads the same backwards as forwards, such as madam or racecar

```js title="palindrome"
function isPalindrome(s) {
  let left = 0;
  let right = s.length - 1;

  while (left < right) {
    if (s[left].toLowerCase() !== s[right].toLowerCase()) {
      return false;
    }

    left++;
    right--;
  }

  return true;
}

console.log(isPalindrome("madam"));
```

### two sum

Return indices of the two numbers such that they add up to target

```js title="two sum"
const twoSum = function (nums, target) {
  const map = new Map();

  for (let i = 0; i < nums.length; i++) {
    const diff = target - nums[i];

    if (map.has(diff)) {
      return [i, map.get(diff)];
    }

    map.set(nums[i], i);
  }

  return null;
};

console.log(twoSum([2, 7, 11, 15], 9));
```

### longest substring with unique characters

The length of the longest substring without repeating characters

```js title="longest substring unique"
function lengthOfLongestSubstring(s) {
  let charSet = new Set();
  let left = 0;
  let maxLength = 0;

  for (let right = 0; right < s.length; right++) {
    while (charSet.has(s[right])) {
      charSet.delete(s[left]);
      left++;
    }
    charSet.add(s[right]);
    maxLength = Math.max(maxLength, right - left + 1);
  }

  return maxLength;
}

const s = "abcabcbb";
const result = lengthOfLongestSubstring(s);
console.log(result); // Output: 3

const s2 = "bbbb";
const result2 = lengthOfLongestSubstring(s2);
console.log(result2); // Output: 1
```

### maximum subarray

The subarray with the largest sum

```js title="maximum subarray"
function maxSubArray(nums) {
  const numsArr = Array.from(nums);
  let maxSum = numsArr[0];

  for (let i = 1; i < numsArr.length; i++) {
    numsArr[i] = Math.max(0, numsArr[i - 1]) + numsArr[i];

    if (numsArr[i] > maxSum) maxSum = numsArr[i];
  }
  return maxSum; // return the contiguous subarray which has the largest sum...
}

const nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4];
// The subarray [4,-1,2,1] has the largest sum 6
console.log(maxSubArray(nums)); // 6
```

### next greater element

The next greater element for each value of nums1 is as follows:
- `4` is underlined in nums2 = `[1,3,4,2]`. There is no next greater element, so the answer is `-1`.
- `1` is underlined in nums2 = `[1,3,4,2]`. The next greater element is `3`.
- `2` is underlined in nums2 = `[1,3,4,2]`. There is no next greater element, so the answer is `-1`.

```js title="next greater element"
const nextGreaterElement = function (nums1, nums2) {
  const map = new Map(); // map for next greater element
  const stack = [];
  for (let num of nums2) {
    while (stack.length && stack[stack.length - 1] < num) {
      map.set(stack.pop(), num);
    }
    stack.push(num);
  }
  for (let i = 0; i < nums1.length; i++) {
    nums1[i] = map.has(nums1[i]) ? map.get(nums1[i]) : -1;
  }
  return nums1;
};

console.log(nextGreaterElement([4, 1, 2], [1, 3, 4, 2]));
// [ -1, 3, -1 ]
```

### daily temperatures

Returns an array answer such that `answer[i]` is the number of days you have to wait after the
`i`<sup>`th`</sup> day to get a warmer temperature.

```js title="daily temperatures"
const dailyTemperatures = function (temperatures) {
  const stack = [];
  const result = new Array(temperatures.length).fill(0);

  for (let i = 0; i < temperatures.length; i++) {
    while (
      stack.length > 0 &&
      temperatures[i] > temperatures[stack[stack.length - 1]]
    ) {
      const idx = stack.pop();
      result[idx] = i - idx;
    }

    stack.push(i);
  }

  return result;
};

const temperatures = [73, 74, 75, 71, 69, 72, 76, 73];
console.log(dailyTemperatures(temperatures));
// [1, 1, 4, 2, 1, 1, 0, 0];
```

### merge intervals

Merges all overlapping intervals, and returns an array of the non-overlapping intervals
that cover all the intervals in the input\
Input: intervals = `[[1,3],[2,6],[8,10],[15,18]]`\
Output: `[[1,6],[8,10],[15,18]]`\
Explanation: Since intervals `[1,3]` and `[2,6]` overlap, merge them into `[1,6]`

```js title="merge intervals"
const mergeIntervals = function (intervals) {
  intervals.sort((a, b) => a[0] - b[0]);

  const merged = [];
  let prev = intervals[0];

  for (let i = 1; i < intervals.length; i++) {
    let interval = intervals[i];
    if (interval[0] <= prev[1]) {
      prev[1] = Math.max(prev[1], interval[1]);
    } else {
      merged.push(prev);
      prev = interval;
    }
  }

  merged.push(prev);
  return merged;
};

const intervals = [
  [1, 3],
  [2, 6],
  [8, 10],
  [15, 18],
];

console.log(mergeIntervals(intervals));
// [[1,6],[8,10],[15,18]]
```

### insert interval

Insert newInterval into intervals such that intervals is still sorted in ascending order
by `start[i]` and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary)\
Input: intervals = `[[1,2],[3,5],[6,7],[8,10],[12,16]]`, newInterval = `[4,8]`\
Output: `[[1,2],[3,10],[12,16]]`\
Explanation: Because the new interval `[4,8]` overlaps with `[3,5],[6,7],[8,10]`

```js title="insert interval"
const insertIntervals = function (intervals, newInterval) {
  let i = 0;
  let n = intervals.length;
  let result = [];

  while (i < intervals.length) {
    if (intervals[i][1] < newInterval[0]) {
      result.push(intervals[i]);
    } else if (intervals[i][0] > newInterval[1]) {
      break;
    } else {
      newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
      newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
    }
    i++;
  }

  result.push(newInterval);

  while (i < n) {
    result.push(intervals[i++]);
  }

  return result;
};

const intervals = [
  [1, 2],
  [3, 5],
  [6, 7],
  [8, 10],
  [12, 16],
];
const newInterval = [4, 8];
console.log(insertIntervals(intervals, newInterval));
// [ [ 1, 2 ], [ 3, 10 ], [ 12, 16 ] ]
```

### non-overlapping intervals

Returns the minimum number of intervals you need to remove to make the rest of
the intervals non-overlapping\
Input: intervals = `[[1,2],[2,3],[3,4],[1,3]]`\
Output: `1`\
Explanation: `[1,3]` can be removed and the rest of the intervals are non-overlapping

```js title="non-overlapping intervals"
const eraseOverlapIntervals = function (intervals) {
  let res = 0;
  intervals.sort((a, b) => a[1] - b[1]);
  let prev_end = intervals[0][1];

  for (let i = 1; i < intervals.length; i++) {
    if (prev_end > intervals[i][0]) {
      res++;
    } else {
      prev_end = intervals[i][1];
    }
  }
  return res;
};

const intervals = [
  [1, 2],
  [2, 3],
  [3, 4],
  [1, 3],
];
console.log(eraseOverlapIntervals(intervals));
// 1
```

### merge strings alternately

Merge the strings by adding letters in alternating order, starting with word1.
If a string is longer than the other, append the additional letters onto the
end of the merged string

```js title="merge strings alternately"
const mergeAlternately = function (word1, word2) {
  let merged = [];

  for (let i = 0; i < Math.max(word1.length, word2.length); i++) {
    if (i < word1.length) {
      merged.push(word1[i]);
    }

    if (i < word2.length) {
      merged.push(word2[i]);
    }
  }

  return merged.join("");
};

const word1 = "abc";
const word2 = "pqr";
console.log(mergeAlternately(word1, word2));
// apbqcr
```

### move zeroes

Given an integer array nums, move all 0's to the end of it while
maintaining the relative order of the non-zero elements

```js title="move zeroes"
const moveZeroes = function (nums) {
  let left = 0;
  let right = nums.length - 1;
  while (left <= right) {
    if (nums[left] === 0) {
      let oldVal = left;
      while (left < right) {
        nums[left] = nums[left + 1];
        left++;
      }
      nums[right] = 0;
      right--;

      if (nums[oldVal] === 0) {
        left = oldVal;
      } else {
        left = oldVal + 1;
      }
    } else {
      left++;
    }
  }
  return nums;
};

const numArray = [0, 1, 0, 3, 12];
console.log(moveZeroes(numArray));
// [ 1, 3, 12, 0, 0 ]
```

### find the difference of two arrays

```js title="difference of 2 arrays"
const findDifference = function (nums1, nums2) {
  let seenLeft = new Set(nums1);
  let seenRight = new Set(nums2);
  let ans = [[], []];

  for (let i of seenLeft) {
    if (!seenRight.has(i)) {
      ans[0].push(i);
    }
  }

  for (let i of seenRight) {
    if (!seenLeft.has(i)) {
      ans[1].push(i);
    }
  }

  return ans;
};

const nums1 = [1, 2, 3];
const nums2 = [2, 4, 6];
console.log(findDifference(nums1, nums2));
// [ [ 1, 3 ], [ 4, 6 ] ]
```

### asteroids collision

We are given an array asteroids of integers representing asteroids in a row.

For each asteroid, the absolute value represents its size, and the sign represents
its direction (positive meaning right, negative meaning left). Each asteroid
moves at the same speed.

Find out the state of the asteroids after all collisions. If two asteroids meet,
the smaller one will explode. If both are the same size, both will explode.
Two asteroids moving in the same direction will never meet.

```js title="asteroids collision"
const asteroidsCollision = function (asteroids) {
  const res = [];

  for (let i = 0; i < asteroids.length; i++) {
    const last = res[res.length - 1];
    const cur = asteroids[i];

    if (!res.length || last < 0 || cur > 0) {
      res.push(cur);
    } else if (-cur === last) {
      res.pop();
    } else if (-cur > last) {
      res.pop();
      i--;
    }
  }

  return res;
};

const asteroids = [5, 10, -5];
console.log(asteroidsCollision(asteroids)); // [ 5, 10 ]
const asteroids2 = [10, 2, -5];
console.log(asteroidsCollision(asteroids2)); // [ 10 ]
```

### divide array into equal pairs

```js title="divide into equal pairs"
const divideArray = function (arr) {
  if (arr.length % 2 !== 0) {
    return false;
  }

  const map = new Map();

  for (let i = 0; i < arr.length; i++) {
    if (!map.get(arr[i])) {
      map.set(arr[i], 1);
    } else {
      map.delete(arr[i]);
    }
  }

  return Array.from(map.keys()).length === 0;
};

const numsArray = [3, 2, 3, 2, 2, 2];
console.log(divideArray(numsArray)); // true
console.log(divideArray([1,2,3,4])); // false
```

### intersection of 2 arrays

```js title="intersection"
const arraysIntersection = function (nums1, nums2) {
  let set1 = new Set(nums1);
  let set2 = new Set(nums2);
  let result = [];

  for (let nums of set2) {
    if (set1.has(nums)) {
      result.push(nums);
    }
  }

  return result;
};

const nums1 = [1, 2, 2, 1];
const nums2 = [2, 2];
console.log(arraysIntersection(nums1, nums2)); // [ 2 ]

const nums3 = [4, 9, 5];
const nums4 = [9, 4, 9, 8, 4];
console.log(arraysIntersection(nums3, nums4)); // [ 9, 4 ]
```

### sort people

```js title="sort people"
const sortPeople = function (names, heights) {
  const array = [];
  const result = [];
  for (let i = 0; i < names.length; i++) {
    array.push([names[i], heights[i]]);
  }
  array.sort((a, b) => b[1] - a[1]);
  for (const arr of array) {
    result.push(arr[0]);
  }
  return result;
};

const names = ["Mary", "John", "Emma"];
const heights = [180, 165, 170];
console.log(sortPeople(names, heights));
```


### best time to buy and sell stocks

Input: prices = `[7,1,5,3,6,4]`
Output: `5`
Explanation: Buy on day `2 (price = 1)` and sell on day `5 (price = 6)`, profit = `6-1 = 5`

```js title="sort people"
const maxProfit = function (prices) {
  let buy = prices[0];
  let profit = 0;
  for (let i = 1; i < prices.length; i++) {
    if (prices[i] < buy) {
      buy = prices[i];
    } else if (prices[i] - buy > profit) {
      profit = prices[i] - buy;
    }
  }
  return profit;
};

const prices = [7, 1, 5, 3, 6, 4];
console.log(maxProfit(prices)); // 5
```



